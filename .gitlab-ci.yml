# GitLab CI/CD Pipeline for Lineage
# Simplified, reliable pipeline with frontend + backend bundled in single image

stages:
  - build
  - test
  - quality
  - package
  - deploy

variables:
  # Registry configuration
  REGISTRY_URL: registry.ftco.ca
  IMAGE_NAME: ${REGISTRY_URL}/${CI_PROJECT_PATH}
  
  # Disable Docker-in-Docker TLS for simplicity
  DOCKER_TLS_CERTDIR: ""

# ============================================================================
# BUILD STAGE
# ============================================================================

build:backend:
  stage: build
  image: gradle:8.10.0-jdk21-jammy
  script:
    - echo "Building backend with Gradle..."
    - gradle build -x test --no-daemon
  artifacts:
    paths:
      - build/libs/*.jar
    expire_in: 1 hour
  cache:
    key: ${CI_COMMIT_REF_SLUG}-gradle
    paths:
      - .gradle/
  needs: []

build:frontend:
  stage: build
  image: node:20-alpine
  script:
    - echo "Building frontend with npm..."
    - cd frontend
    - npm ci --prefer-offline --no-audit
    # Build without type-checking (tests run separately)
    - npx vite build
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 hour
  cache:
    key: ${CI_COMMIT_REF_SLUG}-npm
    paths:
      - frontend/node_modules/
  needs: []

# ============================================================================
# TEST STAGE
# ============================================================================

test:backend:
  stage: test
  image: gradle:8.10.0-jdk21-jammy
  script:
    - echo "Running backend tests..."
    - gradle test jacocoTestReport --no-daemon
  artifacts:
    paths:
      - build/reports/jacoco/test/jacocoTestReport.xml
      - build/test-results/test/
    reports:
      junit: build/test-results/test/**/TEST-*.xml
    expire_in: 1 week
  coverage: '/Total.*?([0-9]{1,3})%/'
  needs:
    - build:backend

test:frontend:
  stage: test
  image: node:20-alpine
  script:
    - echo "Running frontend tests..."
    - cd frontend
    - npm ci --prefer-offline --no-audit
    - npm run test:coverage
  artifacts:
    paths:
      - frontend/coverage/lcov.info
      - frontend/test-report.xml
    reports:
      junit: frontend/test-report.xml
    expire_in: 1 week
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  cache:
    key: ${CI_COMMIT_REF_SLUG}-npm
    paths:
      - frontend/node_modules/
    policy: pull
  needs:
    - build:frontend

# ============================================================================
# QUALITY STAGE
# ============================================================================

quality:sonar:
  stage: quality
  image:
    name: sonarsource/sonar-scanner-cli:11
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  script:
    - echo "Running SonarQube analysis..."
    - sonar-scanner
      -Dsonar.host.url="${SONAR_HOST_URL}"
      -Dsonar.token="${SONAR_TOKEN}"
      -Dsonar.projectKey="${CI_PROJECT_PATH_SLUG}"
      -Dsonar.projectName="${CI_PROJECT_NAME}"
      -Dsonar.sources=src/main/java,frontend/src
      -Dsonar.tests=src/test/java,frontend/src
      -Dsonar.java.binaries=build/classes
      -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml
      -Dsonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "production"
  needs:
    - test:backend
    - test:frontend

# ============================================================================
# PACKAGE STAGE - Build and Push Docker Image
# ============================================================================

package:image:
  stage: package
  image:
    name: gcr.io/kaniko-project/executor:v1.23.0-debug
    entrypoint: [""]
  before_script:
    - echo "Preparing Kaniko authentication..."
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${REGISTRY_URL}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  script:
    - |
      echo "Building and pushing Docker image..."
      
      # Determine tags based on branch
      TAGS=""
      
      # Always tag with commit ref slug (branch name)
      TAGS="--destination ${IMAGE_NAME}:${CI_COMMIT_REF_SLUG}"
      
      # Add 'latest' tag for main/master/production branches
      if [ "$CI_COMMIT_REF_NAME" = "main" ] || [ "$CI_COMMIT_REF_NAME" = "master" ] || [ "$CI_COMMIT_REF_NAME" = "production" ]; then
        TAGS="$TAGS --destination ${IMAGE_NAME}:latest"
      fi
      
      # Add 'production' tag for production branch
      if [ "$CI_COMMIT_REF_NAME" = "production" ]; then
        TAGS="$TAGS --destination ${IMAGE_NAME}:production"
      fi
      
      # Build and push with Kaniko
      /kaniko/executor \
        --context "${CI_PROJECT_DIR}" \
        --dockerfile "${CI_PROJECT_DIR}/Dockerfile" \
        $TAGS \
        --cache=true \
        --cache-repo="${IMAGE_NAME}/cache" \
        --cache-ttl=168h \
        --cleanup
      
      echo "âœ… Image pushed successfully!"
      echo "ðŸ“¦ Available tags:"
      echo "$TAGS" | sed 's/--destination/  -/g'
  rules:
    # Build on merge requests
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # Build on main branches
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "production"
  needs:
    - test:backend
    - test:frontend

# ============================================================================
# OPTIONAL: GitHub Sync (if using mirror)
# ============================================================================

sync:github:
  stage: quality
  image: bitnami/git:latest
  script:
    - echo "Syncing to GitHub mirror..."
    - git remote add github https://${GITHUB_TOKEN}@github.com/AnnapolisLabs/Lineage.git || git remote set-url github https://${GITHUB_TOKEN}@github.com/AnnapolisLabs/Lineage.git
    - git push github HEAD:refs/heads/main --force
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  needs: []
  allow_failure: true


deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $CONTAINER_PROJECT_HOST >> ~/.ssh/known_hosts
  script:
    - |
      echo "ðŸš€ Deploying to production server: $CONTAINER_PROJECT_HOST"
      ssh $SSH_USER@$CONTAINER_PROJECT_HOST << 'ENDSSH'
        set -e
        cd ~/lineage
        echo "ðŸ“¦ Pulling latest image..."
        podman-compose -f docker-compose.yml pull
        echo "ðŸ”„ Restarting services..."
        podman-compose -f docker-compose.yml up -d
        echo "â³ Waiting for application to start..."
        sleep 60
      ENDSSH
      
      echo "ðŸ” Verifying deployment health..."
      MAX_RETRIES=10
      RETRY_COUNT=0
      
      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
        HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$CONTAINER_PROJECT_HOST:8080/actuator/health || echo "000")
        
        if [ "$HEALTH_RESPONSE" = "200" ]; then
          echo "âœ… Deployment successful! Application is healthy."
          exit 0
        fi
        
        echo "âš ï¸  Health check failed (HTTP $HEALTH_RESPONSE), retrying in 10 seconds..."
        RETRY_COUNT=$((RETRY_COUNT + 1))
        sleep 10
      done
      
      echo "âŒ Deployment failed! Application not healthy after $MAX_RETRIES attempts."
      ssh $SSH_USER@$CONTAINER_PROJECT_HOST << 'ENDSSH'
        cd ~/lineage
        podman-compose logs --tail=50 app
      ENDSSH
      exit 1
  rules:
    - if: $CI_COMMIT_BRANCH == "production"
  needs:
    - package:image
  environment:
    name: production
    url: http://$CONTAINER_PROJECT_HOST:8080
